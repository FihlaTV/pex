<!DOCTYPE html>

<html>
<head>
  <title>Octree.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>Octree.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> geom = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pex-geom'</span>);

<span class="hljs-keyword">var</span> Vec3 = geom.Vec3;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>position is bottom left corner of the cell</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Octree</span><span class="hljs-params">(position, size, accuracy)</span> </span>{
  <span class="hljs-keyword">this</span>.maxDistance = <span class="hljs-built_in">Math</span>.max(size.x, <span class="hljs-built_in">Math</span>.max(size.y, size.z));
  <span class="hljs-keyword">this</span>.accuracy = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">new</span> Octree.Cell(<span class="hljs-keyword">this</span>, position, size, <span class="hljs-number">0</span>);
}

Octree.fromBoundingBox = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bbox)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Octree(bbox.min.clone(), bbox.getSize().clone());
};

Octree.MaxLevel = <span class="hljs-number">8</span>;

Octree.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, data)</span> </span>{
  <span class="hljs-keyword">this</span>.root.add(p, data);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>check if the point was already added to the octreee</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Octree.prototype.has = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.root.has(p);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>includeData - return both point and it’s data, defaults to false
maxDist - don’t include points further than maxDist, defaults to Inifinity
notSelf - return point only if different than submited point, defaults to false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Octree.prototype.findNearestPoint = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, options)</span> </span>{
  options.includeData = options.includeData ? options.includeData : <span class="hljs-literal">false</span>;
  options.bestDist = options.maxDist ? options.maxDist : <span class="hljs-literal">Infinity</span>;
  options.notSelf = options.notSelf ? options.notSelf : <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.root.findNearestPoint(p, options);
  <span class="hljs-keyword">if</span> (result) {
    <span class="hljs-keyword">if</span> (options.includeData) <span class="hljs-keyword">return</span> result;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> result.point;
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};

Octree.prototype.findNearbyPoints = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, r, options)</span> </span>{
  options = options || { };
  <span class="hljs-keyword">var</span> result = { points: [], data: [] };
  <span class="hljs-keyword">this</span>.root.findNearbyPoints(p, r, result, options);
  <span class="hljs-keyword">return</span> result;
};

Octree.prototype.getAllCellsAtLevel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cell, level, result)</span> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> level == <span class="hljs-string">'undefined'</span>) {
    level = cell;
    cell = <span class="hljs-keyword">this</span>.root;
  }
  result = result || [];
  <span class="hljs-keyword">if</span> (cell.level == level) {
    <span class="hljs-keyword">if</span> (cell.points.length &gt; <span class="hljs-number">0</span>) {
      result.push(cell);
    }
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">else</span> {
    cell.children.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(child)</span> </span>{
      <span class="hljs-keyword">this</span>.getAllCellsAtLevel(child, level, result);
    }.bind(<span class="hljs-keyword">this</span>));
    <span class="hljs-keyword">return</span> result;
  }
};

Octree.Cell = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(tree, position, size, level)</span> </span>{
  <span class="hljs-keyword">this</span>.tree = tree;
  <span class="hljs-keyword">this</span>.position = position;
  <span class="hljs-keyword">this</span>.size = size;
  <span class="hljs-keyword">this</span>.level = level;
  <span class="hljs-keyword">this</span>.points = [];
  <span class="hljs-keyword">this</span>.data = [];
  <span class="hljs-keyword">this</span>.temp = <span class="hljs-keyword">new</span> Vec3(); <span class="hljs-comment">//temp vector for distance calculation</span>
  <span class="hljs-keyword">this</span>.children = [];
};

Octree.Cell.prototype.has = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p)</span> </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.contains(p))
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.children.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.children.length; i++) {
      <span class="hljs-keyword">var</span> duplicate = <span class="hljs-keyword">this</span>.children[i].has(p);
      <span class="hljs-keyword">if</span> (duplicate) {
        <span class="hljs-keyword">return</span> duplicate;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> minDistSqrt = <span class="hljs-keyword">this</span>.tree.accuracy * <span class="hljs-keyword">this</span>.tree.accuracy;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.points.length; i++) {
      <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">this</span>.points[i];
      <span class="hljs-keyword">var</span> distSq = p.squareDistance(o);
      <span class="hljs-keyword">if</span> (distSq &lt;= minDistSqrt) {
        <span class="hljs-keyword">return</span> o;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
};

Octree.Cell.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, data)</span> </span>{
  <span class="hljs-keyword">this</span>.points.push(p);
  <span class="hljs-keyword">this</span>.data.push(data);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.children.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>.addToChildren(p, data);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.points.length &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">this</span>.level &lt; Octree.MaxLevel) {
      <span class="hljs-keyword">this</span>.split();
    }
  }
};

Octree.Cell.prototype.addToChildren = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, data)</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.children.length; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.children[i].contains(p)) {
      <span class="hljs-keyword">this</span>.children[i].add(p, data);
      <span class="hljs-keyword">break</span>;
    }
  }
};

Octree.Cell.prototype.contains = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p)</span> </span>{
  <span class="hljs-keyword">return</span> p.x &gt;= <span class="hljs-keyword">this</span>.position.x - <span class="hljs-keyword">this</span>.tree.accuracy
      &amp;&amp; p.y &gt;= <span class="hljs-keyword">this</span>.position.y - <span class="hljs-keyword">this</span>.tree.accuracy
      &amp;&amp; p.z &gt;= <span class="hljs-keyword">this</span>.position.z - <span class="hljs-keyword">this</span>.tree.accuracy
      &amp;&amp; p.x &lt; <span class="hljs-keyword">this</span>.position.x + <span class="hljs-keyword">this</span>.size.x + <span class="hljs-keyword">this</span>.tree.accuracy
      &amp;&amp; p.y &lt; <span class="hljs-keyword">this</span>.position.y + <span class="hljs-keyword">this</span>.size.y + <span class="hljs-keyword">this</span>.tree.accuracy
      &amp;&amp; p.z &lt; <span class="hljs-keyword">this</span>.position.z + <span class="hljs-keyword">this</span>.size.z + <span class="hljs-keyword">this</span>.tree.accuracy;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>1 2 3 4
5 6 7 8</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Octree.Cell.prototype.split = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">this</span>.position.x;
  <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">this</span>.position.y;
  <span class="hljs-keyword">var</span> z = <span class="hljs-keyword">this</span>.position.z;
  <span class="hljs-keyword">var</span> w2 = <span class="hljs-keyword">this</span>.size.x / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> h2 = <span class="hljs-keyword">this</span>.size.y / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">this</span>.size.z / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">new</span> Octree.Cell(<span class="hljs-keyword">this</span>.tree, Vec3.create(x, y, z), Vec3.create(w2, h2, d2), <span class="hljs-keyword">this</span>.level + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">new</span> Octree.Cell(<span class="hljs-keyword">this</span>.tree, Vec3.create(x + w2, y, z), Vec3.create(w2, h2, d2), <span class="hljs-keyword">this</span>.level + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">new</span> Octree.Cell(<span class="hljs-keyword">this</span>.tree, Vec3.create(x, y, z + d2), Vec3.create(w2, h2, d2), <span class="hljs-keyword">this</span>.level + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">new</span> Octree.Cell(<span class="hljs-keyword">this</span>.tree, Vec3.create(x + w2, y, z + d2), Vec3.create(w2, h2, d2), <span class="hljs-keyword">this</span>.level + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">new</span> Octree.Cell(<span class="hljs-keyword">this</span>.tree, Vec3.create(x, y + h2, z), Vec3.create(w2, h2, d2), <span class="hljs-keyword">this</span>.level + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">new</span> Octree.Cell(<span class="hljs-keyword">this</span>.tree, Vec3.create(x + w2, y + h2, z), Vec3.create(w2, h2, d2), <span class="hljs-keyword">this</span>.level + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">new</span> Octree.Cell(<span class="hljs-keyword">this</span>.tree, Vec3.create(x, y + h2, z + d2), Vec3.create(w2, h2, d2), <span class="hljs-keyword">this</span>.level + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">this</span>.children.push(<span class="hljs-keyword">new</span> Octree.Cell(<span class="hljs-keyword">this</span>.tree, Vec3.create(x + w2, y + h2, z + d2), Vec3.create(w2, h2, d2), <span class="hljs-keyword">this</span>.level + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.points.length; i++) {
    <span class="hljs-keyword">this</span>.addToChildren(<span class="hljs-keyword">this</span>.points[i], <span class="hljs-keyword">this</span>.data[i]);
  }
};

Octree.Cell.prototype.squareDistanceToCenter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(p)</span> </span>{
  <span class="hljs-keyword">var</span> dx = p.x - (<span class="hljs-keyword">this</span>.position.x + <span class="hljs-keyword">this</span>.size.x / <span class="hljs-number">2</span>);
  <span class="hljs-keyword">var</span> dy = p.y - (<span class="hljs-keyword">this</span>.position.y + <span class="hljs-keyword">this</span>.size.y / <span class="hljs-number">2</span>);
  <span class="hljs-keyword">var</span> dz = p.z - (<span class="hljs-keyword">this</span>.position.z + <span class="hljs-keyword">this</span>.size.z / <span class="hljs-number">2</span>);
  <span class="hljs-keyword">return</span> dx * dx + dy * dy + dz * dz;
}

Octree.Cell.prototype.findNearestPoint = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, options)</span> </span>{
  <span class="hljs-keyword">var</span> nearest = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> nearestData = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> bestDist = options.bestDist;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.points.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.children.length == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.points.length; i++) {
      <span class="hljs-keyword">var</span> dist = <span class="hljs-keyword">this</span>.points[i].distance(p);
      <span class="hljs-keyword">if</span> (dist &lt;= bestDist) {
        <span class="hljs-keyword">if</span> (dist == <span class="hljs-number">0</span> &amp;&amp; options.notSelf)
          <span class="hljs-keyword">continue</span>;
        bestDist = dist;
        nearest = <span class="hljs-keyword">this</span>.points[i];
        nearestData = <span class="hljs-keyword">this</span>.data[i];
      }
    }
  }

  <span class="hljs-keyword">var</span> children = <span class="hljs-keyword">this</span>.children;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>traverse children in order from closest to furthest</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> children = <span class="hljs-keyword">this</span>.children
    .map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child)</span> </span>{ <span class="hljs-keyword">return</span> { child: child, dist: child.squareDistanceToCenter(p) } })
    .sort(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{ <span class="hljs-keyword">return</span> a.dist - b.dist; })
    .map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(c)</span> </span>{ <span class="hljs-keyword">return</span> c.child; });

  <span class="hljs-keyword">if</span> (children.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
      <span class="hljs-keyword">var</span> child = children[i];
      <span class="hljs-keyword">if</span> (child.points.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (p.x &lt; child.position.x - bestDist || p.x &gt; child.position.x + child.size.x + bestDist ||
            p.y &lt; child.position.y - bestDist || p.y &gt; child.position.y + child.size.y + bestDist ||
            p.z &lt; child.position.z - bestDist || p.z &gt; child.position.z + child.size.z + bestDist
          ) {
          <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">var</span> childNearest = child.findNearestPoint(p, options);
        <span class="hljs-keyword">if</span> (!childNearest || !childNearest.point) {
          <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">var</span> childNearestDist = childNearest.point.distance(p);
        <span class="hljs-keyword">if</span> (childNearestDist &lt; bestDist) {
          nearest = childNearest.point;
          bestDist = childNearestDist;
          nearestData = childNearest.data;
        }
      }
    }
  }
  <span class="hljs-keyword">return</span> {
    point: nearest,
    data: nearestData
  }
};

Octree.Cell.prototype.findNearbyPoints = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, r, result, options)</span> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.points.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.children.length == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.points.length; i++) {
      <span class="hljs-keyword">var</span> dist = <span class="hljs-keyword">this</span>.points[i].distance(p);
      <span class="hljs-keyword">if</span> (dist &lt;= r) {
        <span class="hljs-keyword">if</span> (dist == <span class="hljs-number">0</span> &amp;&amp; options.notSelf)
          <span class="hljs-keyword">continue</span>;
        result.points.push(<span class="hljs-keyword">this</span>.points[i]);
        <span class="hljs-keyword">if</span> (options.includeData) result.data.push(<span class="hljs-keyword">this</span>.data[i]);
      }
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>children order doesn’t matter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> children = <span class="hljs-keyword">this</span>.children;

  <span class="hljs-keyword">if</span> (children.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
      <span class="hljs-keyword">var</span> child = children[i];
      <span class="hljs-keyword">if</span> (child.points.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (p.x &lt; child.position.x - r || p.x &gt; child.position.x + child.size.x + r ||
            p.y &lt; child.position.y - r || p.y &gt; child.position.y + child.size.y + r ||
            p.z &lt; child.position.z - r || p.z &gt; child.position.z + child.size.z + r
          ) {
          <span class="hljs-keyword">continue</span>;
        }
        child.findNearbyPoints(p, r, result, options);
      }
    }
  }
};

<span class="hljs-built_in">module</span>.exports = Octree;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
