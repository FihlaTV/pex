// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Color, Edge, Face3, Face4, Geometry, Vec2, Vec3, Vec4;

  Vec2 = require('pex/geom/Vec2');
  Vec3 = require('pex/geom/Vec3');
  Vec4 = require('pex/geom/Vec4');
  Edge = require('pex/geom/Edge');
  Face3 = require('pex/geom/Face3');
  Face4 = require('pex/geom/Face4');
  Color = require('pex/color/Color');
  return Geometry = (function() {
    function Geometry(_arg) {
      var colors, edges, faces, indices, normals, tangents, texCoords, vertices;

      vertices = _arg.vertices, normals = _arg.normals, texCoords = _arg.texCoords, tangents = _arg.tangents, colors = _arg.colors, indices = _arg.indices, edges = _arg.edges, faces = _arg.faces;
      if (vertices == null) {
        vertices = true;
      }
      if (normals == null) {
        normals = false;
      }
      if (texCoords == null) {
        texCoords = false;
      }
      if (tangents == null) {
        tangents = false;
      }
      if (indices == null) {
        indices = false;
      }
      if (edges == null) {
        edges = false;
      }
      if (faces == null) {
        faces = true;
      }
      this.attribs = {};
      if (vertices) {
        this.addAttrib('vertices', 'position', 'Vec3');
      }
      if (normals) {
        this.addAttrib('normals', 'normal', 'Vec3');
      }
      if (texCoords) {
        this.addAttrib('texCoords', 'texCoord', 'Vec2');
      }
      if (tangents) {
        this.addAttrib('tangents', 'tangent', 'Vec3');
      }
      if (colors) {
        this.addAttrib('colors', 'color', 'Color');
      }
      if (indices) {
        this.addIndices();
      }
      if (edges) {
        this.addEdges();
      }
      if (faces) {
        this.addFaces();
      }
    }

    Geometry.prototype.addAttrib = function(propertyName, attributeName, type, dynamic) {
      if (type == null) {
        type = 'Vec3';
      }
      if (dynamic == null) {
        dynamic = false;
      }
      this[propertyName] = [];
      this[propertyName].name = attributeName;
      this[propertyName].dirty = true;
      this[propertyName].dynamic = dynamic;
      this[propertyName].type = type;
      this.attribs[propertyName] = this[propertyName];
      return this;
    };

    Geometry.prototype.addFaces = function(dynamic) {
      if (dynamic == null) {
        dynamic = false;
      }
      this.faces = [];
      this.faces.dirty = true;
      this.faces.dynamic = false;
      return this;
    };

    Geometry.prototype.addEdges = function(dynamic) {
      if (dynamic == null) {
        dynamic = false;
      }
      this.edges = [];
      this.edges.dirty = true;
      this.edges.dynamic = false;
      return this;
    };

    Geometry.prototype.addIndices = function(dynamic) {
      if (dynamic == null) {
        dynamic = false;
      }
      this.indices = [];
      this.indices.dirty = true;
      this.indices.dynamic = false;
      return this;
    };

    Geometry.prototype.isDirty = function(attibs) {
      var attrib, attribAlias, dirty, _ref;

      dirty = false;
      dirty || (dirty = this.faces && this.faces.dirty);
      dirty || (dirty = this.edges && this.edges.dirty);
      _ref = this.attribs;
      for (attribAlias in _ref) {
        attrib = _ref[attribAlias];
        dirty || (dirty = attrib.dirty);
      }
      return dirty;
    };

    Geometry.prototype.allocate = function(numVertices) {
      var attrib, attribName, i, _ref, _results;

      _ref = this.attribs;
      _results = [];
      for (attribName in _ref) {
        attrib = _ref[attribName];
        console.log(attrib);
        attrib.length = numVertices;
        _results.push((function() {
          var _i, _ref1, _results1;

          _results1 = [];
          for (i = _i = 0, _ref1 = numVertices - 1; _i <= _ref1; i = _i += 1) {
            if (attrib[i] == null) {
              switch (attrib.type) {
                case 'Vec2':
                  _results1.push(attrib[i] = new Vec2());
                  break;
                case 'Vec3':
                  _results1.push(attrib[i] = new Vec3());
                  break;
                case 'Vec4':
                  _results1.push(attrib[i] = new Vec4());
                  break;
                case 'Color':
                  _results1.push(attrib[i] = new Color());
                  break;
                default:
                  _results1.push(void 0);
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    Geometry.prototype.addEdge = function(a, b) {
      var ab, ba;

      if (!this.edges) {
        this.addEdges();
      }
      if (!this.edgeHash) {
        this.edgeHash = [];
      }
      ab = a + '_' + b;
      ba = a + '_' + a;
      if (!this.edgeHash[ab] && !this.edgeHash[ba]) {
        this.edges.push(new Edge(a, b));
        return this.edgeHash[ab] = this.edgeHash[ba] = true;
      }
    };

    Geometry.prototype.computeEdges = function() {
      var face, _i, _len, _ref, _results;

      _ref = this.faces;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        face = _ref[_i];
        if (face instanceof Face3) {
          this.addEdge(face.a, face.b);
          this.addEdge(face.b, face.c);
          this.addEdge(face.c, face.a);
        }
        if (face instanceof Face4) {
          this.addEdge(face.a, face.b);
          this.addEdge(face.b, face.c);
          this.addEdge(face.c, face.d);
          _results.push(this.addEdge(face.d, face.a));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Geometry;

  })();
});
