(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require("FWaASH"))
},{"FWaASH":3}],3:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],4:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],5:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/omgcanvas
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

var plask = require('plask');
var parseCSSColor = require('./csscolorparser.js').parseCSSColor;

// NOTE(deanm): Although in Chrome for DOM styles it seems to return a string
// of the form rgb() or rgba() always, for <canvas> it seems to return #123123
// syntax except for when there is a non opaque alpha.
function colorToCSSColorString(c) {
  if (c[3] === 1)
    return '#' + (1<<24 | c[0]<<16 | c[1]<<8 | c[2]).toString(16).substr(1);
  // TODO(deanm): Should we limit the alpha's precision (toPrecision()) ?
  return 'rgba(' + c[0] + ', ' + c[1] + ', ' + c[2] + ', ' + c[3] + ')';
}

function CanvasContext(skcanvas) {
  // Each CanvasRenderingContext2D rendering context maintains a stack of
  // drawing states. Drawing states consist of:
  //
  // - The current transformation matrix.
  // - The current clipping region.
  // - The current values of the following attributes: strokeStyle, fillStyle,
  //   globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset,
  //   shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor,
  //   globalCompositeOperation, font, textAlign, textBaseline, direction,
  //   imageSmoothingEnabled.
  // - The current dash list.

  var upaint = new plask.SkPaint();  // Utility paint for internal use.

  var paint = new plask.SkPaint();  // Track top paint element of state_stack.
  paint.setAntiAlias(true);
  paint.setStrokeWidth(1);  // Skia defaults to 0?
  paint.setStrokeMiter(10);  // Skia defaults to 4.

  var state_stack = [{paint: paint,
                      lineWidth: 1,
                      lineCap: 'butt',
                      lineJoin: 'miter',
                      miterLimit: 10,
                      lineDash: [ ],
                      lineDashOffset: 0,
                      strokeColor: [0, 0, 0, 1],
                      strokeStyle: colorToCSSColorString([0, 0, 0, 1]),
                      fillColor: [0, 0, 0, 1],
                      fillStyle: colorToCSSColorString([0, 0, 0, 1])}];
  var state = state_stack[0];  // Track top element of state_stack.

  var path = new plask.SkPath;

  return {
    canvas: skcanvas,  // Back pointer, hopefully enough for width/height/etc.

    // void save();
    save: function() {
      paint = new plask.SkPaint(paint);  // Dup top.
      state = {paint: paint,
               lineWidth: state.lineWidth,
               lineCap: state.lineCap,
               lineJoin: state.lineJoin,
               miterLimit: state.miterLimit,
               lineDash: state.lineDash,  // Read only, no dup().
               lineDashOffset: state.lineDashOffset,
               strokeColor: state.strokeColor,  // Read only, no dup().
               strokeStyle: state.strokeStyle,
               fillColor: state.fillColor,      // Read only, no dup().
               fillStyle: state.fillStyle};
      state_stack.push(state);
      skcanvas.save();  // Matrix and clip.
    },

    // void restore();
    restore: function() {
      if (state_stack.length > 1) {
        state_stack.pop();
        state = state_stack[state_stack.length - 1];
        paint = state.paint;
        skcanvas.restore();  // Matrix and clip.
      }
    },

    // [Custom] attribute custom strokeStyle;
    get strokeStyle() { return state.strokeStyle; },
    set strokeStyle(v) {
      var c = parseCSSColor(v);
      if (c !== null) {
        state.strokeColor = c;
        // Seems to be what browers do for css style properties.
        state.strokeStyle = colorToCSSColorString(c);
      }
    },

    // [Custom] attribute custom fillStyle;
    get fillStyle() { return state.fillStyle; },
    set fillStyle(v) {
      var c = parseCSSColor(v);
      if (c !== null) {
        state.fillColor = c;
        // Seems to be what browers do for css style properties.
        state.fillStyle = colorToCSSColorString(c);
      }
    },

    // attribute float lineWidth;
    get lineWidth() { return state.lineWidth; },
    set lineWidth(v) {
      if ((typeof v) === 'string') v = parseFloat(v);

      // NOTE(deanm): From the spec:
      //   On setting, zero, negative, infinite, and NaN values must be ignored
      if (v > 0 && isFinite(v)) {
        state.lineWidth = v;
        paint.setStrokeWidth(v);
      }
    },

    // [TreatNullAs=NullString] attribute DOMString lineCap;
    // NOTE(deanm): Spec defaults to "butt".
    get lineCap() { return state.lineCap; },
    set lineCap(v) {
      var cap = null;

      // TODO(deanm): Case insensitive or any trimming?
      switch (v) {
        case 'butt': cap = paint.kButtCap; break;
        case 'round': cap = paint.kRoundCap; break;
        case 'square': cap = paint.kSquareCap; break;
        default: return;
      }

      state.lineCap = v;
      paint.setStrokeCap(cap);
    },

    // [TreatNullAs=NullString] attribute DOMString lineJoin;
    // NOTE(deanm): Spec defaults to "miter".
    get lineJoin() { return state.lineJoin; },
    set lineJoin(v) {
      var join = null;

      // TODO(deanm): Case insensitive or any trimming?
      switch (v) {
        case 'round': join = paint.kRoundJoin; break;
        case 'bevel': join = paint.kBevelJoin; break;
        case 'miter': join = paint.kMiterJoin; break;
        default: return;
      }

      state.lineJoin = v;
      paint.setStrokeJoin(join);
    },

    // attribute float miterLimit;
    get miterLimit() { return state.miterLimit; },
    set miterLimit(v) {
      // NOTE(deanm): From the spec:
      //   On setting, zero, negative, infinite, and NaN values must be ignored
      if (v > 0 && isFinite(v)) {
        state.miterLimit = v;
        paint.setStrokeMiter(v);
      }
    },

    // void setLineDash(in sequence<float> dash);
    // NOTE(deanm): From the spec:
    //   Each CanvasDrawingStyles object has a dash list, which is either empty
    //   or consists of an even number of non-negative numbers. Initially, the
    //   dash list must be empty.
    //
    //   When the setLineDash() method is invoked, it must run the following
    //   steps:
    //
    //   Let a be the argument.
    //
    //   If any value in a is not finite (e.g. an Infinity or a NaN value), or
    //   if any value is negative (less than zero), then abort these steps
    //   (without throwing an exception; user agents could show a message on a
    //   developer console, though, as that would be helpful for debugging).
    //
    //   If the number of elements in a is odd, then let a be the
    //   concatentation of two copies of a.
    //
    //   Let the object's dash list be a.
    setLineDash: function(arr) {
      // Chrome will ignore most invalid arguments, but not no argument.
      if (arguments.length === 0) throw new TypeError('Not enough arguments');

      // Chrome seems to clear the dash list on a non-array argument.
      if (!Array.isArray(arr)) arr = [ ];

      for (var i = 0, il = arr.length; i < il; ++i) {
        if (arr[i] < 0 || !isFinite(arr[i])) return;
      }

      if (arr.length & 1) arr = arr.concat(arr);

      state.lineDash = arr;

      // TODO(deanm): Can we optimize to call setDashPathEffect less?
      if (arr.length === 0) {
        paint.clearPathEffect();
      } else {
        paint.setDashPathEffect(state.lineDash, state.lineDashOffset);
      }
    },

    // sequence<float> getLineDash();
    getLineDash: function() {
      return state.lineDash.slice();  // dup.
    },

    // attribute float lineDashOffset;
    get lineDashOffset() { return state.lineDashOffset; },
    set lineDashOffset(v) {
      if ((typeof v) === 'string') v = parseFloat(v);

      // NOTE(deanm): From the spec:
      //   On setting, infinite and NaN values must be ignored
      if (isFinite(v)) {
        state.lineDashOffset = v;
        // TODO(deanm): Can we optimize to call setDashPathEffect less?
        if (state.lineDash.length === 0) {
          paint.clearPathEffect();
        } else {
          paint.setDashPathEffect(state.lineDash, state.lineDashOffset);
        }
      }
    },

    // void setLineWidth(in [Optional=DefaultIsUndefined] float width);
    setLineWidth: function(v) { this.lineWidth = v; },
    // void setLineCap(in [Optional=DefaultIsUndefined] DOMString cap);
    setLineCap: function(v) { this.lineCap = v; },
    // void setLineJoin(in [Optional=DefaultIsUndefined] DOMString join);
    setLineJoin: function(v) { this.lineJoin = v; },
    // void setMiterLimit(in [Optional=DefaultIsUndefined] float limit);
    setMiterLimit: function(v) { this.miterLimit = v; },

    // void clearRect(in [Optional=DefaultIsUndefined] float x,
    //                in [Optional=DefaultIsUndefined] float y,
    //                in [Optional=DefaultIsUndefined] float width,
    //                in [Optional=DefaultIsUndefined] float height);
    clearRect: function(x, y, w, h) {
      upaint.setXfermodeMode(upaint.kClearMode);
      skcanvas.drawRect(upaint, x, y, x+w, y+h);
    },

    // void fillRect(in [Optional=DefaultIsUndefined] float x,
    //               in [Optional=DefaultIsUndefined] float y,
    //               in [Optional=DefaultIsUndefined] float width,
    //               in [Optional=DefaultIsUndefined] float height);
    fillRect: function(x, y, w, h) {
      // TODO(deanm): Avoid the save/restore.
      this.save();
      paint.setFill();
      var c = state.fillColor;
      paint.setColor(c[0], c[1], c[2], (c[3] * 255) >> 0);
      skcanvas.drawRect(paint, x, y, x+w, y+h);
      this.restore();
    },

    // void strokeRect(in [Optional=DefaultIsUndefined] float x,
    //                 in [Optional=DefaultIsUndefined] float y,
    //                 in [Optional=DefaultIsUndefined] float width,
    //                 in [Optional=DefaultIsUndefined] float height,
    //                 in [Optional] float lineWidth);
    // NOTE(deanm): I don't see lineWidth in the current spec.
    strokeRect: function(x, y, w, h) {
      // TODO(deanm): Avoid the save/restore.
      this.save();
      paint.setStroke();
      var c = state.strokeColor;
      paint.setColor(c[0], c[1], c[2], (c[3] * 255) >> 0);
      skcanvas.drawRect(paint, x, y, x+w, y+h);
      this.restore();
    },

    // void beginPath();
    beginPath: function() {
      path.rewind();  // TODO(deanm): reset vs rewind.
    },

    // void closePath();
    closePath: function() {
      path.close();
    },

    // void moveTo(in [Optional=DefaultIsUndefined] float x,
    //             in [Optional=DefaultIsUndefined] float y);
    moveTo: function(x, y) {
      path.moveTo(x, y);
    },

    // void lineTo(in [Optional=DefaultIsUndefined] float x,
    //             in [Optional=DefaultIsUndefined] float y);
    lineTo: function(x, y) {
      path.lineTo(x, y);
    },

    // void rect(in [Optional=DefaultIsUndefined] float x,
    //           in [Optional=DefaultIsUndefined] float y,
    //           in [Optional=DefaultIsUndefined] float width,
    //           in [Optional=DefaultIsUndefined] float height);
    rect: function(x, y, w, h) {
      path.addRect(x, y, x+w, y+h);
    },

    // void arcTo(in [Optional=DefaultIsUndefined] float x1,
    //            in [Optional=DefaultIsUndefined] float y1,
    //            in [Optional=DefaultIsUndefined] float x2,
    //            in [Optional=DefaultIsUndefined] float y2,
    //            in [Optional=DefaultIsUndefined] float radius)
    //     raises (DOMException);
    arcTo: function(x1, y1, x2, y2, radius) {
      path.arct(x1, y1, x2, y2, radius);
    },

    // void arc(in [Optional=DefaultIsUndefined] float x,
    //          in [Optional=DefaultIsUndefined] float y,
    //          in [Optional=DefaultIsUndefined] float radius,
    //          in [Optional=DefaultIsUndefined] float startAngle,
    //          in [Optional=DefaultIsUndefined] float endAngle,
    //          in [Optional=DefaultIsUndefined] boolean anticlockwise)
    //     raises (DOMException);
    arc: function(x, y, radius, startAngle, endAngle, anticlockwise) {
      var sweep = endAngle - startAngle;
      var start_deg = startAngle * 180 / plask.kPI;
      var sweep_deg = sweep * 180 / plask.kPI;

      // See Path::addArc in
      // http://trac.webkit.org/browser/trunk/Source/WebCore/platform/graphics/skia/PathSkia.cpp
      if (sweep_deg >= 360 || sweep_deg <= -360) {  // Circle.
        path.arcTo(x-radius, y-radius, x+radius, y+radius, start_deg, 0);
        path.addOval(x-radius, y-radius, x+radius, y+radius, anticlockwise);
        path.arcTo(x-radius, y-radius, x+radius, y+radius,
                   start_deg+sweep_deg, 0, true);
      } else {
        if (anticlockwise && sweep_deg > 0) sweep_deg -= 360;
        if (!anticlockwise && sweep_deg < 0) sweep_deg += 360;
        path.arcTo(x-radius, y-radius, x+radius, y+radius,
                   start_deg, sweep_deg);
      }
    },

    // void quadraticCurveTo(in [Optional=DefaultIsUndefined] float cpx,
    //                       in [Optional=DefaultIsUndefined] float cpy,
    //                       in [Optional=DefaultIsUndefined] float x,
    //                       in [Optional=DefaultIsUndefined] float y);
    quadraticCurveTo: function(cpx, cpy, x, y) {
      path.quadTo(cpx, cpy, x, y);
    },

    // void bezierCurveTo(in [Optional=DefaultIsUndefined] float cp1x,
    //                    in [Optional=DefaultIsUndefined] float cp1y,
    //                    in [Optional=DefaultIsUndefined] float cp2x,
    //                    in [Optional=DefaultIsUndefined] float cp2y,
    //                    in [Optional=DefaultIsUndefined] float x,
    //                    in [Optional=DefaultIsUndefined] float y);
    bezierCurveTo: function(cpx1, cp1y, cp2x, cp2y, x, y) {
      path.cubicTo(cpx1, cp1y, cp2x, cp2y, x, y);
    },

    // void fill();
    fill: function() {
      // TODO(deanm): Avoid the save/restore.
      this.save();
      paint.setFill();
      var c = state.fillColor;
      paint.setColor(c[0], c[1], c[2], (c[3] * 255) >> 0);
      skcanvas.drawPath(paint, path);
      this.restore();
    },

    // void stroke();
    stroke: function() {
      // TODO(deanm): Avoid the save/restore.
      this.save();
      paint.setStroke();
      var c = state.strokeColor;
      paint.setColor(c[0], c[1], c[2], (c[3] * 255) >> 0);
      skcanvas.drawPath(paint, path);
      this.restore();
    },

    // void clip();
    clip: function() {
      skcanvas.clipPath(path);
    },

    // void scale(in [Optional=DefaultIsUndefined] float sx,
    //            in [Optional=DefaultIsUndefined] float sy);
    scale: function(sx, sy) {
      skcanvas.scale(sx, sy);
    },

    // void rotate(in [Optional=DefaultIsUndefined] float angle);
    rotate: function(angle) {
      skcanvas.rotate(angle * 180 / plask.kPI);
    },

    // void translate(in [Optional=DefaultIsUndefined] float tx,
    //                in [Optional=DefaultIsUndefined] float ty);
    translate: function(tx, ty) {
      skcanvas.translate(tx, ty);
    },

    // void transform(in [Optional=DefaultIsUndefined] float m11,
    //                in [Optional=DefaultIsUndefined] float m12,
    //                in [Optional=DefaultIsUndefined] float m21,
    //                in [Optional=DefaultIsUndefined] float m22,
    //                in [Optional=DefaultIsUndefined] float dx,
    //                in [Optional=DefaultIsUndefined] float dy);
    transform: function(m11, m12, m21, m22, dx, dy) {
      skcanvas.concatMatrix(m11, m21, dx,
                            m12, m22, dy,
                              0,   0,  1);
    },
    // void setTransform(in [Optional=DefaultIsUndefined] float m11,
    //                   in [Optional=DefaultIsUndefined] float m12,
    //                   in [Optional=DefaultIsUndefined] float m21,
    //                   in [Optional=DefaultIsUndefined] float m22,
    //                   in [Optional=DefaultIsUndefined] float dx,
    //                   in [Optional=DefaultIsUndefined] float dy);
    setTransform: function(m11, m12, m21, m22, dx, dy) {
      skcanvas.setMatrix(m11, m21, dx,
                         m12, m22, dy,
                           0,   0,  1);
    },

    // NOTE(deanm): The pixel access is not going to be a particularly great
    // implementation.  But actually even what the browsers do isn't very good,
    // which is why Plask's canvas works different (and BGRA ordering).

    // ImageData createImageData(in ImageData? imagedata)
    //     raises (DOMException);
    // ImageData createImageData(in float sw, in float sh)
    //     raises (DOMException);
    createImageData: function(sw, sh) {
      if (arguments.length === 1) {
        sh = sw.height; sw = sw.width;
      }

      // TODO(deanm): Switch to Uint8ClampedArray.
      var data = new Uint8Array(sw * sh * 4);

      // TODO(deanm): Hopefully there doesn't need to be an ImageData type.
      return {width: sw, height: sh, data: data};
    },

    // ImageData getImageData(in [Optional=DefaultIsUndefined] float sx,
    //                        in [Optional=DefaultIsUndefined] float sy,
    //                        in [Optional=DefaultIsUndefined] float sw,
    //                        in [Optional=DefaultIsUndefined] float sh)
    //     raises(DOMException);
    getImageData: function(sx, sy, sw, sh) {
      var w = skcanvas.width, h = skcanvas.height;
      var id = this.createImageData(sw, sh);
      var data = id.data;
      for (var dy = 0; dy < sh; ++dy) {  // Copy and swizzle.
        var dsl = (dy * sw) << 2;
        var csl = ((sy + dy) * w + sx) << 2;
        for (var dx = 0; dx < sw; ++dx) {
          var b = skcanvas[csl++], g = skcanvas[csl++], r = skcanvas[csl++]
              a = skcanvas[csl++];
          var unpremultiply = a === 0 ? 0 : 255/a;  // Have to unpremultiply.
          data[dsl++] = (r * unpremultiply) >> 0;
          data[dsl++] = (g * unpremultiply) >> 0;
          data[dsl++] = (b * unpremultiply) >> 0;
          data[dsl++] = a;
        }
      }

      return id;
    },

    // void putImageData(in ImageData? imagedata, in float dx, in float dy)
    //     raises(DOMException);
    // void putImageData(in ImageData? imagedata, in float dx, in float dy,
    //                   in float dirtyX, in float dirtyY,
    //                   in float dirtyWidth, in float dirtyHeight)
    //     raises(DOMException);
    putImageData: function(imagedata, sx, sy) {
      // TODO(deanm): Support dirty, although it is only an optimization.
      var w = skcanvas.width, h = skcanvas.height;
      var sw = imagedata.width, sh = imagedata.height;
      var data = imagedata.data;
      for (var dy = 0; dy < sh; ++dy) {  // Copy and swizzle.
        var dsl = (dy * sw) << 2;
        var csl = ((sy + dy) * w + sx) << 2;
        for (var dx = 0; dx < sw; ++dx) {
          var r = data[dsl++], g = data[dsl++]; b = data[dsl++],
              a = data[dsl++];
          var fa = a / 255;  // Have to premultiply.
          skcanvas[csl++] = (b * fa) >> 0;
          skcanvas[csl++] = (g * fa) >> 0;
          skcanvas[csl++] = (r * fa) >> 0;
          skcanvas[csl++] = a;
        }
      }
    },
  };
}

exports.CanvasContext = CanvasContext;

// TODO(deanm): These are the parts of the interface unfinished.

// 
// attribute float globalAlpha;
// [TreatNullAs=NullString] attribute DOMString globalCompositeOperation;
// 
// CanvasGradient createLinearGradient(in [Optional=DefaultIsUndefined] float x0,
//                                     in [Optional=DefaultIsUndefined] float y0,
//                                     in [Optional=DefaultIsUndefined] float x1,
//                                     in [Optional=DefaultIsUndefined] float y1)
//     raises (DOMException);
// CanvasGradient createRadialGradient(in [Optional=DefaultIsUndefined] float x0,
//                                     in [Optional=DefaultIsUndefined] float y0,
//                                     in [Optional=DefaultIsUndefined] float r0,
//                                     in [Optional=DefaultIsUndefined] float x1,
//                                     in [Optional=DefaultIsUndefined] float y1,
//                                     in [Optional=DefaultIsUndefined] float r1)
//     raises (DOMException);
// 
// 
// attribute float shadowOffsetX;
// attribute float shadowOffsetY;
// attribute float shadowBlur;
// [TreatNullAs=NullString] attribute DOMString shadowColor;
//
// // FIXME: These attributes should also be implemented for V8.
// #if !(defined(V8_BINDING) && V8_BINDING)
// [Custom] attribute Array webkitLineDash;
// attribute float webkitLineDashOffset;
// #endif
// 
// 
// boolean isPointInPath(in [Optional=DefaultIsUndefined] float x,
//                       in [Optional=DefaultIsUndefined] float y);
// 
// // text
// attribute DOMString font;
// attribute DOMString textAlign;
// attribute DOMString textBaseline;
// 
// TextMetrics measureText(in [Optional=DefaultIsUndefined] DOMString text);
// 
// // other
// 
// void setAlpha(in [Optional=DefaultIsUndefined] float alpha);
// void setCompositeOperation(in [Optional=DefaultIsUndefined] DOMString compositeOperation);
// 
// void clearShadow();
// 
// void fillText(in DOMString text, in float x, in float y, in [Optional] float maxWidth);
// void strokeText(in DOMString text, in float x, in float y, in [Optional] float maxWidth);
// 
// void setStrokeColor(in [StrictTypeChecking] DOMString color, in [Optional] float alpha);
// void setStrokeColor(in float grayLevel, in [Optional] float alpha);
// void setStrokeColor(in float r, in float g, in float b, in float a);
// void setStrokeColor(in float c, in float m, in float y, in float k, in float a);
// 
// void setFillColor(in [StrictTypeChecking] DOMString color, in [Optional] float alpha);
// void setFillColor(in float grayLevel, in [Optional] float alpha);
// void setFillColor(in float r, in float g, in float b, in float a);
// void setFillColor(in float c, in float m, in float y, in float k, in float a);
// 
// void drawImage(in HTMLImageElement? image, in float x, in float y)
//     raises (DOMException);
// void drawImage(in HTMLImageElement? image, in float x, in float y, in float width, in float height)
//     raises (DOMException);
// void drawImage(in HTMLImageElement? image, in float sx, in float sy, in float sw, in float sh, in float dx, in float dy, in float dw, in float dh)
//     raises (DOMException);
// void drawImage(in HTMLCanvasElement? canvas, in float x, in float y)
//     raises (DOMException);
// void drawImage(in HTMLCanvasElement? canvas, in float x, in float y, in float width, in float height)
//     raises (DOMException);
// void drawImage(in HTMLCanvasElement? canvas, in float sx, in float sy, in float sw, in float sh, in float dx, in float dy, in float dw, in float dh)
//     raises (DOMException);
// #if defined(ENABLE_VIDEO) && ENABLE_VIDEO
// void drawImage(in HTMLVideoElement? video, in float x, in float y)
//     raises (DOMException);
// void drawImage(in HTMLVideoElement? video, in float x, in float y, in float width, in float height)
//     raises (DOMException);
// void drawImage(in HTMLVideoElement? video, in float sx, in float sy, in float sw, in float sh, in float dx, in float dy, in float dw, in float dh)
//     raises (DOMException);
// #endif
// 
// void drawImageFromRect(in HTMLImageElement image,
//                        in [Optional] float sx, in [Optional] float sy, in [Optional] float sw, in [Optional] float sh,
//                        in [Optional] float dx, in [Optional] float dy, in [Optional] float dw, in [Optional] float dh,
//                        in [Optional] DOMString compositeOperation);
// 
// void setShadow(in float width, in float height, in float blur, in [Optional, StrictTypeChecking] DOMString color, in [Optional] float alpha);
// void setShadow(in float width, in float height, in float blur, in float grayLevel, in [Optional] float alpha);
// void setShadow(in float width, in float height, in float blur, in float r, in float g, in float b, in float a);
// void setShadow(in float width, in float height, in float blur, in float c, in float m, in float y, in float k, in float a);
// 
// void webkitPutImageDataHD(in ImageData? imagedata, in float dx, in float dy)
//     raises(DOMException);
// void webkitPutImageDataHD(in ImageData? imagedata, in float dx, in float dy, in float dirtyX, in float dirtyY, in float dirtyWidth, in float dirtyHeight)
//     raises(DOMException);
// 
// CanvasPattern createPattern(in HTMLCanvasElement? canvas, in [TreatNullAs=NullString] DOMString repetitionType)
//     raises (DOMException);
// CanvasPattern createPattern(in HTMLImageElement? image, in [TreatNullAs=NullString] DOMString repetitionType)
//     raises (DOMException);

},{"./csscolorparser.js":4,"plask":1}],6:[function(require,module,exports){
module.exports.Color = require('./lib/Color');
},{"./lib/Color":7}],7:[function(require,module,exports){
//Color utility class

//## Example use
//     var Color = require('pex-color').Color;
//
//     var red = new Color(1.0, 0.0, 0.0, 1.0);
//     var green = Color.fromHSL(0.2, 1.0, 0.0, 0.5);

//## Reference

//Dependencies imports
var lerp = require('lerp');

//### Color(r, g, b, a)  
//RGBA color constructor  
//`r` - red component *{ Number 0..1 }* = 0  
//`g` - green component *{ Number 0..1 }* = 0  
//`b` - blue component *{ Number 0..1 }* = 0  
//`a` - alpha component *{ Number 0..1 }* = 1
function Color(r, g, b, a) {
  this.r = (r !== undefined) ? r : 0;
  this.g = (g !== undefined) ? g : 0;
  this.b = (b !== undefined) ? b : 0;
  this.a = (a !== undefined) ? a : 1;
}

//### create(r, g, b, a)  
//RGBA color constructor function  
//`r` - red component *{ Number 0..1 }* = 0  
//`g` - green component *{ Number 0..1 }* = 0  
//`b` - blue component *{ Number 0..1 }* = 0  
//`a` - alpha opacity *{ Number 0..1 }* = 1
Color.create = function(r, g, b, a) {
  return new Color(r, g, b, a);
};

//### fromRGB(r, g, b, a)  
//Alias for create(r, g, b, a)
Color.fromRGB = Color.create;

//### fromArray(a)  
//Creates new color from array of 4 values [r, g, b, a]  
//`a` - array of rgba values *{ Array of Numbers 0..1 }* = [0, 0, 0, 1]
Color.fromArray = function(a) {
 return new Color(a[0], a[1], a[2], a[3]);
};

//### fromByteArray(a)  
//Creates new color from array of 4 byte values [r, g, b, a]  
//`a` - array of rgba values *{ Array of Numbers/Int 0..255 }* = [0, 0, 0, 255]
Color.fromByteArray = function(a) {
 return new Color(a[0]/255, a[1]/255, a[2]/255, (a.length == 4) ? a[3]/255 : 255);
};

//### fromHSV(h, s, v, a)
//Creates new color from hue, saturation and value  
//`h` - hue *{ Number 0..1 }* = 0  
//`s` - saturation *{ Number 0..1 }* = 0  
//`v` - value *{ Number 0..1 }* = 0  
//`a` - alpha opacity *{ Number 0..1 }* = 1
Color.fromHSV = function(h, s, v, a) {
  var c = new Color();
  c.setHSV(h, s, v, a);
  return c;
};

//### fromHSL(h, s, l, a)
//Creates new color from hue, saturation and lightness  
//`h` - hue *{ Number 0..1 }* = 0  
//`s` - saturation *{ Number 0..1 }* = 0  
//`l` - lightness *{ Number 0..1 }* = 0  
//`a` - alpha opacity *{ Number 0..1 }* = 1
Color.fromHSL = function(h, s, l, a) {
  var c = new Color();
  c.setHSL(h, s, l, a);
  return c;
};

//### fromHex(hex)  
//Creates new color from html hex value e.g. #FF0000  
//`hex` - html hex color string (with or without #) *{ String }*
Color.fromHex = function(hex) {
  var c = new Color();
  c.setHex(hex);
  return c;
};

//### fromXYZ(x, y, z)  
//Creates new color from XYZ representation  
//x - *{ Number 0..1 }*  
//y - *{ Number 0..1 }*  
//z - *{ Number 0..1 }*  
Color.fromXYZ = function(x, y, z) {
  var c = new Color();
  c.setXYZ(x, y, z);
  return c;
};

//### fromLab(l, a, b)  
//Creates new color from Lab representation  
//l - *{ Number 0..100 }*  
//a - *{ Number -128..127 }*  
//b - *{ Number -128..127 }*  
Color.fromLab = function(l, a, b) {
  var c = new Color();
  c.setLab(l, a, b);
  return c;
};

//### set(r, g, b, a)  
//`r` - red component *{ Number 0..1 }* = 0  
//`g` - green component *{ Number 0..1 }* = 0  
//`b` - blue component *{ Number 0..1 }* = 0  
//`a` - alpha opacity *{ Number 0..1 }* = 1
Color.prototype.set = function(r, g, b, a) {
  this.r = r;
  this.g = g;
  this.b = b;
  this.a = (a !== undefined) ? a : 1;

  return this;
};

//### setHSV(h, s, l, a)  
//Sets rgb color values from a hue, saturation, value and alpha  
//`h` - hue *{ Number 0..1 }* = 0  
//`s` - saturation *{ Number 0..1 }* = 0  
//`v` - value *{ Number 0..1 }* = 0  
//`a` - alpha opacity *{ Number 0..1 }* = 1  
Color.prototype.setHSV = function(h, s, v, a) {
  a = a || 1;

  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0: this.r = v; this.g = t; this.b = p; break;
    case 1: this.r = q; this.g = v; this.b = p; break;
    case 2: this.r = p; this.g = v; this.b = t; break;
    case 3: this.r = p; this.g = q; this.b = v; break;
    case 4: this.r = t; this.g = p; this.b = v; break;
    case 5: this.r = v; this.g = p; this.b = q; break;
  }

  this.a = a;
  return this;
};

//### getHSV()  
//Returns hue, saturation, value and alpha of color as  
//*{ Object h:0.1, s:0..1, v:0..1, a:0..1 }*  
Color.prototype.getHSV = function() {
  var r = this.r;
  var g = this.g;
  var b = this.b;
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h;
  var v = max;
  var d = max - min;
  var s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // achromatic
  }
  else {
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return { h: h, s: s, v: v, a: this.a };
};

//### setHSL(h, s, l, a)  
//Sets rgb color values from a hue, saturation, lightness and alpha  
//`h` - hue *{ Number 0..1 }* = 0  
//`s` - saturation *{ Number 0..1 }* = 0  
//`l` - lightness *{ Number 0..1 }* = 0  
//`a` - alpha opacity *{ Number 0..1 }* = 1  
//Based on [https://gist.github.com/mjijackson/5311256](https://gist.github.com/mjijackson/5311256)
Color.prototype.setHSL = function(h, s, l, a) {
  a = a || 1;

  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1/6) { return p + (q - p) * 6 * t; }
    if (t < 1/2) { return q; }
    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
    return p;
  }

  if (s === 0) {
    this.r = this.g = this.b = l; // achromatic
  }
  else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    this.r = hue2rgb(p, q, h + 1/3);
    this.g = hue2rgb(p, q, h);
    this.b = hue2rgb(p, q, h - 1/3);
    this.a = a;
  }

  return this;
};

//### getHSL()  
//Returns hue, saturation, lightness and alpha of color as  
//*{ Object h:0.1, s:0..1, l:0..1, a:0..1 }*  
//Based on [https://gist.github.com/mjijackson/5311256](https://gist.github.com/mjijackson/5311256)
Color.prototype.getHSL = function() {
  var r = this.r;
  var g = this.g;
  var b = this.b;
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var l = (max + min) / 2;
  var h;
  var s;

  if (max === min) {
    h = s = 0; // achromatic
  }
  else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }

    h /= 6;
  }

  return { h: h, s: s, l: l, a: this.a };
};

//### setHex(hex)  
//Sets rgb color values from a html hex value e.g. #FF0000  
//`hex` - html hex color string (with or without #) *{ String }*
Color.prototype.setHex = function(hex) {
  hex = hex.replace(/^#/, "");
  var num = parseInt(hex, 16);

  var color = [ num >> 16, num >> 8 & 255, num & 255 ].map(function(val) {
    return val / 255;
  });

  this.r = color[0];
  this.g = color[1];
  this.b = color[2];

  return this;
};

//### getHex()  
//Returns html hex representation of this color *{ String }*
Color.prototype.getHex = function() {
  var color = [ this.r, this.g, this.b ].map(function(val) {
    return Math.floor(val * 255);
  });

  return "#" + ((color[2] | color[1] << 8 | color[0] << 16) | 1 << 24)
    .toString(16)
    .slice(1)
    .toUpperCase();
};


//### setXYZ(x, y, z)  
//Sets rgb color values from XYZ
//x - *{ Number 0..1 }*  
//y - *{ Number 0..1 }*  
//z - *{ Number 0..1 }*  
Color.prototype.setXYZ = function(x, y, z) {
  var rgb = {
    r: x *  3.2406 + y * -1.5372 + z * -0.4986,
    g: x * -0.9689 + y *  1.8758 + z *  0.0415,
    b: x *  0.0557 + y * -0.2040 + z *  1.0570
  };

  [ "r", "g", "b" ].forEach(function(key) {
    rgb[key] /= 100;

    if (rgb[key] < 0) {
      rgb[key] = 0;
    }

    if (rgb[key] > 0.0031308) {
      rgb[key] = 1.055 * Math.pow(rgb[key], (1 / 2.4)) - 0.055;
    }
    else {
      rgb[key] *= 12.92;
    }
  });

  this.r = rgb.r;
  this.g = rgb.g;
  this.b = rgb.b;
  this.a = 1.0;

  return this;
};

//### getXYZ()  
//Returns xyz representation of this color as  
//*{ Object x:0..1, y:0..1, z:0..1 }*  
Color.prototype.getXYZ = function() {
  var rgb = this.clone();

  [ "r", "g", "b" ].forEach(function(key) {
    if (rgb[key] > 0.04045) {
      rgb[key] = Math.pow(((rgb[key] + 0.055) / 1.055), 2.4);
    } else {
      rgb[key] /= 12.92;
    }

    rgb[key] = rgb[key] * 100;
  });

  return {
    x: rgb.r * 0.4124 + rgb.g * 0.3576 + rgb.b * 0.1805,
    y: rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722,
    z: rgb.r * 0.0193 + rgb.g * 0.1192 + rgb.b * 0.9505
  };
};

//### setLab(l, a, b)  
//Sets rgb color values from Lab  
//l - *{ Number 0..100 }*  
//a - *{ Number -128..127 }*  
//b - *{ Number -128..127 }*  
Color.prototype.setLab = function(l, a, b) {
  var y = (l + 16) / 116;
  var x = a / 500 + y;
  var z = y - b / 200;

  var xyz = { x: x, y: y, z: z };
  var pow;

  [ "x", "y", "z" ].forEach(function(key) {
    pow = Math.pow(xyz[key], 3);

    if (pow > 0.008856) {
      xyz[key] = pow;
    }
    else {
      xyz[key] = (xyz[key] - 16 / 116) / 7.787;
    }
  });

  var color = Color.fromXYZ(xyz.x, xyz.y, xyz.z);

  this.r = color.r;
  this.g = color.g;
  this.b = color.b;
  this.a = color.a;

  return this;
};

//### getLab()  
//Returns Lab representation of this color as  
//*{ Object l: 0..100, a: -128..127, b: -128..127 }*  
Color.prototype.getLab = function() {
  var white = { x: 95.047, y: 100.000, z: 108.883 };
  var xyz = this.getXYZ();

  [ "x", "y", "z" ].forEach(function(key) {
    xyz[key] /= white[key];

    if (xyz[key] > 0.008856) {
      xyz[key] = Math.pow(xyz[key], 1 / 3);
    }
    else {
      xyz[key] = (7.787 * xyz[key]) + (16 / 116);
    }
  });

  return {
    l: 116 * xyz.y - 16,
    a: 500 * (xyz.x - xyz.y),
    b: 200 * (xyz.y - xyz.z)
  };
};

//### copy()  
//Copies rgba values from another color into this instance  
//`c` - another color to copy values from *{ Color }*
Color.prototype.copy = function(c) {
  this.r = c.r;
  this.g = c.g;
  this.b = c.b;
  this.a = c.a;

  return this;
};

//### clone()  
//Returns a copy of this color *{ Color }*
Color.prototype.clone = function() {
  return new Color(this.r, this.g, this.b, this.a);
};

//### hash()  
//Returns one (naive) hash number representation of this color *{ Number }*
Color.prototype.hash = function() {
  return 1 * this.r + 12 * this.g + 123 * this.b + 1234 * this.a;
};

//### distance(color)  
//Returns distance (CIE76) between this and given color using Lab representation *{ Number }*  
//Based on [http://en.wikipedia.org/wiki/Color_difference](http://en.wikipedia.org/wiki/Color_difference)
Color.prototype.distance = function(color) {
  var lab1 = this.getLab();
  var lab2 = color.getLab();

  var dl = lab2.l - lab1.l;
  var da = lab2.a - lab1.a;
  var db = lab2.b - lab1.b;

  return Math.sqrt(dl * dl, da * da, db * db);
};

//### lerp(startColor, endColor, t, mode)  
//Creates new color from linearly interpolated two colors  
//`startColor` - *{ Color }*  
//`endColor` - *{ Color } *  
//`t` - interpolation ratio *{ Number 0..1 }*  
//`mode` - interpolation mode : 'rgb', 'hsv', 'hsl' *{ String }* = 'rgb'  
Color.lerp = function(startColor, endColor, t, mode) {
  mode = mode || 'rgb';

  if (mode === 'rgb') {
    return Color.fromRGB(
      lerp(startColor.r, endColor.r, t),
      lerp(startColor.g, endColor.g, t),
      lerp(startColor.b, endColor.b, t),
      lerp(startColor.a, endColor.a, t)
    );
  }
  else if (mode === 'hsv') {
    var startHSV = startColor.getHSV();
    var endHSV = endColor.getHSV();
    return Color.fromHSV(
      lerp(startHSV.h, endHSV.h, t),
      lerp(startHSV.s, endHSV.s, t),
      lerp(startHSV.v, endHSV.v, t),
      lerp(startHSV.a, endHSV.a, t)
    );
  }
  else if (mode === 'hsl') {
    var startHSL = startColor.getHSL();
    var endHSL = endColor.getHSL();
    return Color.fromHSL(
      lerp(startHSL.h, endHSL.h, t),
      lerp(startHSL.s, endHSL.s, t),
      lerp(startHSL.l, endHSL.l, t),
      lerp(startHSL.a, endHSL.a, t)
    );
  }
  else {
    return startColor;
  }
};

//## Predefined colors ready to use

Color.Transparent = new Color(0, 0, 0, 0);
Color.None = new Color(0, 0, 0, 0);
Color.Black = new Color(0, 0, 0, 1);
Color.White = new Color(1, 1, 1, 1);
Color.DarkGrey = new Color(0.25, 0.25, 0.25, 1);
Color.Grey = new Color(0.5, 0.5, 0.5, 1);
Color.LightGrey = new Color(0.75, 0.75, 0.75, 1);
Color.Red = new Color(1, 0, 0, 1);
Color.Green = new Color(0, 1, 0, 1);
Color.Blue = new Color(0, 0, 1, 1);
Color.Yellow = new Color(1, 1, 0, 1);
Color.Pink = new Color(1, 0, 1, 1);
Color.Cyan = new Color(0, 1, 1, 1);
Color.Orange = new Color(1, 0.5, 0, 1);

module.exports = Color;

},{"lerp":8}],8:[function(require,module,exports){
function lerp(v0, v1, t) {
    return v0*(1-t)+v1*t
}
module.exports = lerp
},{}],9:[function(require,module,exports){
module.exports.Platform = require('./lib/Platform');
module.exports.Window = require('./lib/Window');
module.exports.Time = require('./lib/Time');
module.exports.IO = require('./lib/IO');
module.exports.Log = require('./lib/Log');
},{"./lib/IO":11,"./lib/Log":12,"./lib/Platform":13,"./lib/Time":14,"./lib/Window":15}],10:[function(require,module,exports){
var Platform = require('./Platform');
var Log = require('./Log');
var merge = require('merge');

var requestAnimFrameFps = 60;

if (Platform.isBrowser) {
  window.requestAnimFrame = function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      window.setTimeout(callback, 1000 / requestAnimFrameFps);
    };
  }();
}
var eventListeners = [];
function fireEvent(eventType, event) {
  for (var i = 0; i < eventListeners.length; i++) {
    if (eventListeners[i].eventType == eventType) {
      eventListeners[i].handler(event);
    }
  }
}

function registerEvents(canvas, win) {
  makeMouseDownHandler(canvas, win);
  makeMouseUpHandler(canvas, win);
  makeMouseDraggedHandler(canvas, win);
  makeMouseMovedHandler(canvas, win);
  makeScrollWheelHandler(canvas, win);
  makeTouchDownHandler(canvas, win);
  makeTouchUpHandler(canvas, win);
  makeTouchMoveHandler(canvas, win);
  makeKeyDownHandler(canvas, win);
  makeWindowResizeHandler(canvas, win);
}

function makeMouseDownHandler(canvas, win) {
  canvas.addEventListener('mousedown', function(e) {
    fireEvent('leftMouseDown', {
      x: (e.offsetX || e.layerX || e.clientX - e.target.offsetLeft) * win.settings.highdpi,
      y: (e.offsetY || e.layerY || e.clientY - e.target.offsetTop) * win.settings.highdpi,
      option: e.altKey,
      shift: e.shiftKey,
      control: e.ctrlKey
    });
  });
}

function makeMouseUpHandler(canvas, win) {
  canvas.addEventListener('mouseup', function(e) {
    fireEvent('leftMouseUp', {
      x: (e.offsetX || e.layerX || e.clientX - e.target.offsetLeft) * win.settings.highdpi,
      y: (e.offsetY || e.layerY || e.clientY - e.target.offsetTop) * win.settings.highdpi,
      option: e.altKey,
      shift: e.shiftKey,
      control: e.ctrlKey
    });
  });
}

function makeMouseDraggedHandler(canvas, win) {
  var down = false;
  var px = 0;
  var py = 0;
  canvas.addEventListener('mousedown', function(e) {
    down = true;
    px = (e.offsetX || e.layerX || e.clientX - e.target.offsetLeft) * win.settings.highdpi;
    py = (e.offsetY || e.layerY || e.clientY - e.target.offsetTop) * win.settings.highdpi;
  });
  canvas.addEventListener('mouseup', function(e) {
    down = false;
  });
  canvas.addEventListener('mousemove', function(e) {
    if (down) {
      var x = (e.offsetX || e.layerX || e.clientX - e.target.offsetLeft) * win.settings.highdpi;
      var y = (e.offsetY || e.layerY || e.clientY - e.target.offsetTop) * win.settings.highdpi;
      fireEvent('mouseDragged', {
        x: x,
        y: y,
        dx: x - px,
        dy: y - py,
        option: e.altKey,
        shift: e.shiftKey,
        control: e.ctrlKey
      });
      px = x;
      py = y;
    }
  });
}

function makeMouseMovedHandler(canvas, win) {
  canvas.addEventListener('mousemove', function(e) {
    fireEvent('mouseMoved', {
      x: (e.offsetX || e.layerX || e.clientX - e.target.offsetLeft) * win.settings.highdpi,
      y: (e.offsetY || e.layerY || e.clientY - e.target.offsetTop) * win.settings.highdpi,
      option: e.altKey,
      shift: e.shiftKey,
      control: e.ctrlKey
    });
  });
}

function makeScrollWheelHandler(canvas, win) {
  var mousewheelevt = /Firefox/i.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel';
  document.addEventListener(mousewheelevt, function(e) {
    fireEvent('scrollWheel', {
      x: (e.offsetX || e.layerX) * win.settings.highdpi,
      y: (e.offsetY || e.layerY) * win.settings.highdpi,
      dy: e.wheelDelta / 10 || -e.detail / 10,
      option: e.altKey,
      shift: e.shiftKey,
      control: e.ctrlKey
    });
  });
}
var lastTouch = null;
function makeTouchDownHandler(canvas, win) {
  canvas.addEventListener('touchstart', function(e) {
    lastTouch = {
      clientX: e.touches[0].clientX * win.settings.highdpi,
      clientY: e.touches[0].clientY * win.settings.highdpi
    };
    var touches = Array.prototype.slice.call(this, e.touches).map(function(touch) {
      touch.x = touch.clientX * win.settings.highdpi;
      touch.y = touch.clientY * win.settings.highdpi;
      return touch;
    });
    fireEvent('leftMouseDown', {
      x: e.touches[0].clientX * win.settings.highdpi,
      y: e.touches[0].clientY * win.settings.highdpi,
      option: false,
      shift: false,
      control: false,
      touches: touches
    });
  });
}

function makeTouchUpHandler(canvas, win) {
  canvas.addEventListener('touchend', function(e) {
    var touches = Array.prototype.slice.call(this, e.touches).map(function(touch) {
      touch.x = touch.clientX * win.settings.highdpi;
      touch.y = touch.clientY * win.settings.highdpi;
      return touch;
    });
    fireEvent('leftMouseUp', {
      x: lastTouch ? lastTouch.clientX : 0,
      y: lastTouch ? lastTouch.clientY : 0,
      option: false,
      shift: false,
      control: false,
      touches: touches
    });
    lastTouch = null;
  });
}

function makeTouchMoveHandler(canvas, win) {
  canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    lastTouch = {
      clientX: e.touches[0].clientX * win.settings.highdpi,
      clientY: e.touches[0].clientY * win.settings.highdpi
    };
    var touches = Array.prototype.slice.call(this, e.touches).map(function(touch) {
      touch.x = touch.clientX * win.settings.highdpi;
      touch.y = touch.clientY * win.settings.highdpi;
      return touch;
    });
    fireEvent('mouseDragged', {
      x: e.touches[0].clientX * win.settings.highdpi,
      y: e.touches[0].clientY * win.settings.highdpi,
      option: false,
      shift: false,
      control: false,
      touches: touches
    });
    return false;
  });
}

function makeKeyDownHandler(canvas, win) {
  var timeout = 0;
  window.addEventListener('keydown', function(e) {
    timeout = setTimeout(function() {
      fireEvent('keyDown', {
        str: '',
        keyCode: e.keyCode,
        option: e.altKey,
        shift: e.shiftKey,
        control: e.ctrlKey
      }, 1);
    });
  });
  window.addEventListener('keypress', function(e) {
    if (timeout) {
      clearTimeout(timeout);
      timeout = 0;
    }
    fireEvent('keyDown', {
      str: String.fromCharCode(e.charCode),
      keyCode: e.keyCode,
      option: e.altKey,
      shift: e.shiftKey,
      control: e.ctrlKey
    });
  });
}

function makeWindowResizeHandler(canvas, win) {
  window.addEventListener('resize', function(e) {
    var width = window.innerWidth;
    var height = window.innerHeight;

    if (win.settings.fullscreen) {
      canvas.width = width * win.settings.highdpi;
      canvas.height = height * win.settings.highdpi;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      win.width = width * win.settings.highdpi;
      win.height = height * win.settings.highdpi;
    }

    fireEvent('resize', { width: width, height: height });
  });
}

function simpleWindow(obj) {
  var canvas = obj.settings.canvas;
  if (obj.settings.fullscreen) {
    obj.settings.width = window.innerWidth;
    obj.settings.height = window.innerHeight;
  }
  if (!canvas) {
    canvas = document.getElementById('canvas');
  }
  else if (obj.settings.width && obj.settings.height) {
    canvas.width = obj.settings.width;
    canvas.height = obj.settings.height;
  }
  else {
    obj.settings.width = canvas.width;
    obj.settings.height = canvas.height;
  }
  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.width = obj.settings.width;
    canvas.height = obj.settings.height;
  }
  if (window.devicePixelRatio == 2) {
    if (obj.settings.highdpi == 2) {
      canvas.width = obj.settings.width * 2;
      canvas.height = obj.settings.height * 2;
      canvas.style.width = obj.settings.width + 'px';
      canvas.style.height = obj.settings.height + 'px';
      obj.settings.width = canvas.width;
      obj.settings.height = canvas.height;
    }
  }
  else {
    obj.settings.highdpi = 1;
  }

  if (obj.settings.multisample) {
    canvas.msaaEnabled = true;
    canvas.msaaSamples = 2;
  }

  obj.width = obj.settings.width;
  obj.height = obj.settings.height;
  obj.canvas = canvas;
  canvas.style.backgroundColor = '#000000';
  function go() {
    if (obj.stencil === undefined)
      obj.stencil = false;
    if (obj.settings.fullscreen) {
      document.body.style.margin = '0';
      document.body.style.padding = '0';
      document.body.style.overflow = 'hidden';
    }
    var gl = null;
    var ctx = null;
    if (obj.settings.type == '3d') {
      try {
        gl = canvas.getContext('experimental-webgl', {
          antialias: true,
          stencil: obj.settings.stencil,
          premultipliedAlpha : obj.settings.premultipliedAlpha,
          preserveDrawingBuffer: obj.settings.preserveDrawingBuffer
        });
      }
      catch (err) {
        Log.error(err.message);
        return;
      }
      if (gl === null) {
        throw 'No WebGL context is available.';
      }
    }else if (obj.settings.type == '2d') {
      ctx = canvas.getContext('2d');
    }
    obj.framerate = function(fps) {
      requestAnimFrameFps = fps;
    };
    obj.on = function(eventType, handler) {
      eventListeners.push({
        eventType: eventType,
        handler: handler
      });
    };
    registerEvents(canvas, obj);
    obj.dispose = function() {
      obj.__disposed = true;
    };
    obj.gl = gl;
    obj.ctx = ctx;
    obj.init();
    function drawloop() {
      if (!obj.__disposed) {
        obj.draw();
        requestAnimFrame(drawloop);
      }
    }
    requestAnimFrame(drawloop);
  }
  if (!canvas.parentNode) {
    if (document.body) {
      document.body.appendChild(canvas);
      go();
    }else {
      window.addEventListener('load', function() {
        document.body.appendChild(canvas);
        go();
      }, false);
    }
  }
  else {
    go();
  }
  return obj;
}

var BrowserWindow = { simpleWindow: simpleWindow };

module.exports = BrowserWindow;

},{"./Log":12,"./Platform":13,"merge":16}],11:[function(require,module,exports){
(function (process){
var Platform = require('./Platform');
var Log = require('./Log');
var plask = require('plask');
var path = require('path');

var merge = require('merge');

var PlaskIO = function() {
  function IO() {
  }

  IO.loadTextFile = function (file, callback) {
    var fullPath = path.resolve(IO.getWorkingDirectory(), file);
    if (!fs.existsSync(fullPath)) {
      if (callback) {
        return callback(null);
      }
    }
    var data = fs.readFileSync(fullPath, 'utf8');
    if (callback) {
      callback(data);
    }
  };

  IO.getWorkingDirectory = function () {
    return path.dirname(process.mainModule.filename);
  };

  //textureHandle - texture handl
  //textureTarget - gl.TEXTURE_2D, gl.TEXTURE_CUBE
  //dataTarget - gl.TEXTURE_2D, gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
  IO.loadImageData = function (gl, textureHandle, textureTarget, dataTarget, file, options, callback) {
    var defaultOptions = { flip: false, lod: 0 };
    options = merge(defaultOptions, options);
    var fullPath = path.resolve(IO.getWorkingDirectory(), file);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(textureTarget, textureHandle);
    var canvas = plask.SkCanvas.createFromImage(fullPath);
    if (options.flip) {
      gl.texImage2DSkCanvas(dataTarget, options.lod, canvas);
    }
    else {
      gl.texImage2DSkCanvasNoFlip(dataTarget, options.lod, canvas);
    }
    if (callback) {
      callback(canvas);
    }
  };

  IO.watchTextFile = function (file, callback) {
    fs.watch(file, {}, function (event, fileName) {
      if (event == 'change') {
        var data = fs.readFileSync(file, 'utf8');
        if (callback) {
          callback(data);
        }
      }
    });
  };

  IO.saveTextFile = function (file, data) {
    fs.writeFileSync(file, data);
  };
  return IO;
};

var WebIO = function () {
  function IO() {
  }

  IO.getWorkingDirectory = function () {
    return '.';
  };

  IO.loadTextFile = function (url, callback) {
    var request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.onreadystatechange = function (e) {
      if (request.readyState == 4) {
        if (request.status == 200) {
          if (callback) {
            callback(request.responseText);
          }
        } else {
          Log.error('WebIO.loadTextFile error : ' + request.statusText);
        }
      }
    };
    request.send(null);
  };

  IO.loadImageData = function (gl, textureHandle, textureTarget, dataTarget, url, options, callback) {
    var defaultOptions = { flip: false, lod: 0 };
    options = merge(defaultOptions, options);
    var image = new Image();
    if (options.crossOrigin) image.crossOrigin = options.crossOrigin;
    image.onload = function () {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(textureTarget, textureHandle);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flip);
      gl.texImage2D(dataTarget, options.lod, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      if (callback) {
        callback(image);
      }
    };
    image.src = url;
  };

  IO.watchTextFile = function () {
    console.log('Warning: WebIO.watch is not implemented!');
  };

  IO.saveTextFile = function (url, data, callback) {
    var request = new XMLHttpRequest();
    request.open('POST', url, true);
    request.onreadystatechange = function (e) {
      if (request.readyState == 4) {
        if (request.status == 200) {
          if (callback) {
            callback(request.responseText, request);
          }
        } else {
          Log.error('WebIO.saveTextFile error : ' + request.statusText);
        }
      }
    };
    request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    request.send('data=' + encodeURIComponent(data));
  };

  return IO;
};

if (Platform.isPlask) module.exports = PlaskIO();
else if (Platform.isBrowser) module.exports = WebIO();
}).call(this,require("FWaASH"))
},{"./Log":12,"./Platform":13,"FWaASH":3,"merge":16,"path":2,"plask":1}],12:[function(require,module,exports){
function Log() {
}

Log.message = function(msg) {
  if (console !== undefined) {
    var msgs = Array.prototype.slice.call(arguments);
    console.log(msgs.join(' '));
  }
};

Log.error = function(msg) {
  var msgs = Array.prototype.slice.call(arguments);
  if (console !== undefined) {
    console.log('ERROR: ' + msgs.join(' '));
  }
};

module.exports = Log;
},{}],13:[function(require,module,exports){
(function (process){
module.exports.isPlask = typeof window === 'undefined' && typeof process === 'object';
module.exports.isBrowser = typeof window === 'object' && typeof document === 'object';
module.exports.isEjecta = typeof ejecta === 'object' && typeof ejecta.include === 'function';
module.exports.isiOS = module.exports.isBrowser && typeof navigator === 'object' && /(iPad|iPhone|iPod)/g.test( navigator.userAgent );
module.exports.isMobile = module.exports.isiOS;
}).call(this,require("FWaASH"))
},{"FWaASH":3}],14:[function(require,module,exports){
var Log = require('./Log');

var Time = {
    now: 0,
    prev: 0,
    delta: 0,
    seconds: 0,
    frameNumber: 0,
    fpsFrames: 0,
    fpsTime: 0,
    fps: 0,
    fpsFrequency: 3,
    paused: false,
    verbose: false
};

Time.update = function(delta) {
  if (Time.paused) {
    return;
  }

  if (Time.prev === 0) {
    Time.prev = Date.now();
  }

  Time.now = Date.now();
  Time.delta = (delta !== undefined) ? delta : (Time.now - Time.prev) / 1000;

  //More than 1s = probably switched back from another window so we have big jump now
  if (Time.delta > 1) {
    Time.delta = 0;
  }

  Time.prev = Time.now;
  Time.seconds += Time.delta;
  Time.fpsTime += Time.delta;
  Time.frameNumber++;
  Time.fpsFrames++;

  if (Time.fpsTime > Time.fpsFrequency) {
    Time.fps = Time.fpsFrames / Time.fpsTime;
    Time.fpsTime = 0;
    Time.fpsFrames = 0;
    if (this.verbose)
      Log.message('FPS: ' + Time.fps);
  }
  return Time.seconds;

};

var startOfMeasuredTime = 0;

Time.startMeasuringTime = function() {
  startOfMeasuredTime = Date.now();
};

Time.stopMeasuringTime = function(msg) {
  var now = Date.now();
  var seconds = (now - startOfMeasuredTime) / 1000;
  if (msg) {
    console.log(msg + seconds);
  }
  return seconds;
};

Time.pause = function() {
  Time.paused = true;
};

Time.togglePause = function() {
  Time.paused = !Time.paused;
};

Time.reset = function() {
  Time.now = 0;
  Time.prev = 0;
  Time.delta = 0;
  Time.seconds = 0;
  Time.frameNumber = 0;
  Time.fpsFrames = 0;
}

module.exports = Time;
},{"./Log":12}],15:[function(require,module,exports){
var Platform = require('./Platform');
var BrowserWindow = require('./BrowserWindow');
var Time = require('./Time');
var Log = require('./Log');
var merge = require('merge');
var plask = require('plask');

var DefaultSettings = {
  'width': 1280,
  'height': 720,
  'type': '3d',
  'vsync': true,
  'multisample': true,
  'fullscreen': false,
  'center': true,
  'highdpi': 1,
  'stencil': false,
  'premultipliedAlpha': true,
  'preserveDrawingBuffer': false,
  'screen': 0
};

var Window = {
  currentWindow: null,
  create: function(obj) {
    obj.settings = obj.settings || {};
    obj.settings = merge(DefaultSettings, obj.settings);

    if (obj.settings.fullscreen) {
      var screens;

      if (Platform.isPlask) {
        screens = plask.Window.screensInfo();
      }
      else {
        screens = [ { width: window.innerWidth, height: window.innerHeight } ];
      }

      if (obj.settings.screen !== undefined) {
        var screen = screens[obj.settings.screen];
        if (screen) {
          obj.settings.position = { x: 0, y: screen.height };
          obj.settings.width = screen.width * obj.settings.highdpi;
          obj.settings.height = screen.height * obj.settings.highdpi;
        }
      }
    }

    obj.__init = obj.init;
    obj.init = function() {
      Window.currentWindow = this;
      obj.framerate(60);
      if (obj.__init) {
        obj.__init();
      }
    }

    obj.__draw = obj.draw;
    obj.draw = function() {
      Window.currentWindow = this;
      //FIXME: this will cause Time update n times, where n is number of Window instances opened
      Time.update();
      if (obj.__draw) {
        obj.__draw();
      }
    }

    if (Platform.isPlask) {
      plask.simpleWindow(obj);
    }
    else if (Platform.isBrowser || Platform.isEjecta) {
      BrowserWindow.simpleWindow(obj);
    }
  }
};

module.exports = Window;

},{"./BrowserWindow":10,"./Log":12,"./Platform":13,"./Time":14,"merge":16,"plask":1}],16:[function(require,module,exports){
/*!
 * @name JavaScript/NodeJS Merge v1.2.0
 * @author yeikos
 * @repository https://github.com/yeikos/js.merge

 * Copyright 2014 yeikos - MIT license
 * https://raw.github.com/yeikos/js.merge/master/LICENSE
 */

;(function(isNode) {

	/**
	 * Merge one or more objects 
	 * @param bool? clone
	 * @param mixed,... arguments
	 * @return object
	 */

	var Public = function(clone) {

		return merge(clone === true, false, arguments);

	}, publicName = 'merge';

	/**
	 * Merge two or more objects recursively 
	 * @param bool? clone
	 * @param mixed,... arguments
	 * @return object
	 */

	Public.recursive = function(clone) {

		return merge(clone === true, true, arguments);

	};

	/**
	 * Clone the input removing any reference
	 * @param mixed input
	 * @return mixed
	 */

	Public.clone = function(input) {

		var output = input,
			type = typeOf(input),
			index, size;

		if (type === 'array') {

			output = [];
			size = input.length;

			for (index=0;index<size;++index)

				output[index] = Public.clone(input[index]);

		} else if (type === 'object') {

			output = {};

			for (index in input)

				output[index] = Public.clone(input[index]);

		}

		return output;

	};

	/**
	 * Merge two objects recursively
	 * @param mixed input
	 * @param mixed extend
	 * @return mixed
	 */

	function merge_recursive(base, extend) {

		if (typeOf(base) !== 'object')

			return extend;

		for (var key in extend) {

			if (typeOf(base[key]) === 'object' && typeOf(extend[key]) === 'object') {

				base[key] = merge_recursive(base[key], extend[key]);

			} else {

				base[key] = extend[key];

			}

		}

		return base;

	}

	/**
	 * Merge two or more objects
	 * @param bool clone
	 * @param bool recursive
	 * @param array argv
	 * @return object
	 */

	function merge(clone, recursive, argv) {

		var result = argv[0],
			size = argv.length;

		if (clone || typeOf(result) !== 'object')

			result = {};

		for (var index=0;index<size;++index) {

			var item = argv[index],

				type = typeOf(item);

			if (type !== 'object') continue;

			for (var key in item) {

				var sitem = clone ? Public.clone(item[key]) : item[key];

				if (recursive) {

					result[key] = merge_recursive(result[key], sitem);

				} else {

					result[key] = sitem;

				}

			}

		}

		return result;

	}

	/**
	 * Get type of variable
	 * @param mixed input
	 * @return string
	 *
	 * @see http://jsperf.com/typeofvar
	 */

	function typeOf(input) {

		return ({}).toString.call(input).slice(8, -1).toLowerCase();

	}

	if (isNode) {

		module.exports = Public;

	} else {

		window[publicName] = Public;

	}

})(typeof module === 'object' && module && typeof module.exports === 'object' && module.exports);
},{}],17:[function(require,module,exports){
var sys = require('pex-sys');
var color = require('pex-color');
var omgcanvas = require('omgcanvas');
var Window = sys.Window;
var Color = color.Color;
var Platform = sys.Platform;

Window.create({
  settings: {
    width: 1024,
    height: 550,
    type: '2d',
    fullscreen: sys.Platform.isBrowser
  },
  init: function() {
    if (Platform.isBrowser) {
      this.context = this.canvas.getContext('2d');
    }
    else { //Plask
      //create HTML Canvas wrapper on top of Skia SkCanvas
      this.context = new omgcanvas.CanvasContext(this.canvas);
    }
  },
  draw: function() {
    var ctx = this.context;
    ctx.fillStyle = Color.fromRGB(50/255, 50/255, 50/255, 1).getHex();
    ctx.fillRect(0, 0, this.width, this.height);

    var c = new Color();

    var numRect = 50;
    for(var i=0; i<numRect; i++) {
      ctx.save();

      var hue = i / numRect;
      var t = i / numRect;
      var step = 1 / numRect;

      ctx.translate(0, 10);
      c.set(t, 0.5, 0.5);
      ctx.fillStyle = c.getHex();
      ctx.fillRect(this.width * t, 0, this.width * (t + step), 50);

      ctx.translate(0, 60);
      c.set(0.5, t, 0.5);
      ctx.fillStyle = c.getHex();
      ctx.fillRect(this.width * t, 0, this.width * (t + step), 50);

      ctx.translate(0, 60);
      c.set(0.5, 0.5, t);
      ctx.fillStyle = c.getHex();
      ctx.fillRect(this.width * t, 0, this.width * (t + step), 50);

      ctx.translate(0, 60);
      c.setHSV(hue, 1.0, 1.0);
      ctx.fillStyle = c.getHex();
      ctx.fillRect(this.width * t, 0, this.width * (t + step), 50);

      ctx.translate(0, 60);
      c.setHSV(hue, 0.5, 1.0);
      ctx.fillStyle = c.getHex();
      ctx.fillRect(this.width * t, 0, this.width * (t + step), 50);

      ctx.translate(0, 60);
      c.setHSV(hue, 1.0, 0.5);
      ctx.fillStyle = c.getHex();
      ctx.fillRect(this.width * t, 0, this.width * (t + step), 50);

      ctx.translate(0, 60);
      c.setHSL(hue, 1.0, 0.8);
      ctx.fillStyle = c.getHex();
      ctx.fillRect(this.width * t, 0, this.width * (t + step), 50);

      ctx.translate(0, 60);
      c.setHSL(hue, 0.5, 0.5);
      ctx.fillStyle = c.getHex();
      ctx.fillRect(this.width * t, 0, this.width * (t + step), 50);

      ctx.translate(0, 60);
      c.setHSL(hue, 1.0, 0.5);
      ctx.fillStyle = c.getHex();
      ctx.fillRect(this.width * t, 0, this.width * (t + step), 50);

      ctx.restore();
    }
  }
})

},{"omgcanvas":5,"pex-color":6,"pex-sys":9}]},{},[17])